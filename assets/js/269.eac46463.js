(window.webpackJsonp=window.webpackJsonp||[]).push([[269],{344:function(e,v,s){"use strict";s.r(v);var r=s(0),_=Object(r.a)({},(function(){var e=this,v=e.$createElement,s=e._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"promise-a-规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-a-规范"}},[e._v("#")]),e._v(" Promise/A+ 规范")]),e._v(" "),s("p",[e._v("Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 then 方法，该方法注册了两个回调函数，用于接收 Promise 的终值或本 Promise 不能执行的原因。")]),e._v(" "),s("p",[e._v("本规范详细列出了 then 方法的执行过程，所有遵循 Promises/A+ 规范实现的 Promise 均可以本标准作为参照基础来实施 then 方法。因而本规范是十分稳定的。尽管 Promise/A+ 组织有时可能会修订本规范，但主要是为了处理一些特殊的边界情况，且这些改动都是微小且向下兼容的。如果我们要进行大规模不兼容的更新，我们一定会在事先进行谨慎地考虑、详尽的探讨和严格的测试。")]),e._v(" "),s("p",[e._v("从历史上说，本规范实际上是把之前 Promise/A 规范 中的建议明确成为了行为标准：我们一方面扩展了原有规范约定俗成的行为，一方面删减了原规范的一些特例情况和有问题的部分。")]),e._v(" "),s("p",[e._v("最后，核心的 Promises/A+ 规范不设计如何创建、解决和拒绝 Promise，而是专注于提供一个通用的 then 方法。上述对于 Promises 的操作方法将来在其他规范中可能会提及。")]),e._v(" "),s("h2",{attrs:{id:"规范术语"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#规范术语"}},[e._v("#")]),e._v(" 规范术语")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("解决（fulfill）")]),e._v("：指一个 Promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 Promise 实现多以 resolve 来指代之。")]),e._v(" "),s("li",[s("strong",[e._v("拒绝（reject）")]),e._v("：指一个 Promise 失败时进行的一系列操作。")]),e._v(" "),s("li",[s("strong",[e._v("终值（eventual value）")]),e._v("：所谓终值，指的是 Promise 被解决时传递给解决回调的值，由于 Promise 有一次性的特征，因此当这个值被传递时，标志着 Promise 等待态的结束，故称之终值，有时也直接简称为值（value）。")]),e._v(" "),s("li",[s("strong",[e._v("拒因（reason）")]),e._v("：也就是拒绝原因，指在 Promise 被拒绝时传递给拒绝回调的值。")])]),e._v(" "),s("h2",{attrs:{id:"术语"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#术语"}},[e._v("#")]),e._v(" 术语")]),e._v(" "),s("ul",[s("li",[s("p",[s("strong",[e._v("Promise")]),e._v("：Promise 是一个拥有 then 方法的对象或函数，其行为符合本规范；")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("thenable")]),e._v('：是一个定义了 then 方法的对象或函数，文中译作"拥有 '),s("code",[e._v("then")]),e._v(' 方法"；')])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("值（value）")]),e._v("：指任何 JavaScript 的合法值（包括 undefined , thenable 和 Promise）；")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("异常（exception）")]),e._v("：是使用 throw 语句抛出的一个值。")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("拒因（reason）")]),e._v("：表示一个 Promise 的拒绝原因。")])])]),e._v(" "),s("h2",{attrs:{id:"状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态"}},[e._v("#")]),e._v(" 状态")]),e._v(" "),s("p",[e._v("一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。")]),e._v(" "),s("h3",{attrs:{id:"等待态（pending）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#等待态（pending）"}},[e._v("#")]),e._v(" 等待态（Pending）")]),e._v(" "),s("p",[e._v("处于等待态时，Promise 需满足以下条件：")]),e._v(" "),s("ul",[s("li",[e._v("可以迁移至执行态或拒绝态")])]),e._v(" "),s("h3",{attrs:{id:"执行态（fulfilled）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行态（fulfilled）"}},[e._v("#")]),e._v(" 执行态（Fulfilled）")]),e._v(" "),s("p",[e._v("处于执行态时，Promise 需满足以下条件：")]),e._v(" "),s("ul",[s("li",[e._v("不能迁移至其他任何状态")]),e._v(" "),s("li",[e._v("必须拥有一个不可变的终值")])]),e._v(" "),s("h3",{attrs:{id:"拒绝态（rejected）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拒绝态（rejected）"}},[e._v("#")]),e._v(" 拒绝态（Rejected）")]),e._v(" "),s("p",[e._v("处于拒绝态时，Promise 需满足以下条件：")]),e._v(" "),s("ul",[s("li",[e._v("不能迁移至其他任何状态")]),e._v(" "),s("li",[e._v("必须拥有一个不可变的拒因")])]),e._v(" "),s("p",[e._v("这里的不可变指的是恒等（即可用 "),s("code",[e._v("===")]),e._v(" 判断相等），而不是意味着更深层次的不可变（译者注：盖指当 value 或 reason 不是基本数据类型时，只要求其引用地址相等，但属性值可被更改）。")]),e._v(" "),s("h2",{attrs:{id:"then-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#then-方法"}},[e._v("#")]),e._v(" Then 方法")]),e._v(" "),s("p",[e._v("一个 Promise 必须提供一个 "),s("code",[e._v("then")]),e._v(" 方法以访问其"),s("strong",[e._v("当前值")]),e._v("、"),s("strong",[e._v("终值")]),e._v("和"),s("strong",[e._v("拒因")]),e._v("。")]),e._v(" "),s("p",[e._v("Promise 的 then 方法接受两个参数：")]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[e._v("Promise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("onFulfilled"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" onRejected"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("h3",{attrs:{id:"参数可选"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参数可选"}},[e._v("#")]),e._v(" 参数可选")]),e._v(" "),s("p",[e._v("onFulfilled 和 onRejected 都是可选参数。")]),e._v(" "),s("ul",[s("li",[e._v("如果 onFulfilled 不是函数，其必须被忽略")]),e._v(" "),s("li",[e._v("如果 onRejected 不是函数，其必须被忽略")])]),e._v(" "),s("h3",{attrs:{id:"onfulfilled-特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#onfulfilled-特性"}},[e._v("#")]),e._v(" onFulfilled 特性")]),e._v(" "),s("p",[e._v("如果 onFulfilled 是函数：")]),e._v(" "),s("ul",[s("li",[e._v("当 Promise 执行结束后其必须被调用，其第一个参数为 Promise 的终值")]),e._v(" "),s("li",[e._v("在 Promise 执行结束前其不可被调用")]),e._v(" "),s("li",[e._v("其调用次数不可超过一次")])]),e._v(" "),s("h3",{attrs:{id:"onrejected-特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#onrejected-特性"}},[e._v("#")]),e._v(" onRejected 特性")]),e._v(" "),s("p",[e._v("如果 onRejected 是函数：")]),e._v(" "),s("ul",[s("li",[e._v("当 Promise 被拒绝执行后其必须被调用，其第一个参数为 Promise 的拒因")]),e._v(" "),s("li",[e._v("在 Promise 被拒绝执行前其不可被调用")]),e._v(" "),s("li",[e._v("其调用次数不可超过一次")])]),e._v(" "),s("h3",{attrs:{id:"调用时机"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调用时机"}},[e._v("#")]),e._v(" 调用时机")]),e._v(" "),s("p",[e._v("onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用。"),s("a",{attrs:{href:"#%E6%B3%A81"}},[e._v("注 1")])]),e._v(" "),s("h3",{attrs:{id:"调用要求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调用要求"}},[e._v("#")]),e._v(" 调用要求")]),e._v(" "),s("p",[e._v("onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）"),s("a",{attrs:{href:"#%E6%B3%A82"}},[e._v("注 2")])]),e._v(" "),s("h3",{attrs:{id:"多次调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多次调用"}},[e._v("#")]),e._v(" 多次调用")]),e._v(" "),s("p",[s("code",[e._v("then")]),e._v(" 方法可以被同一个 Promise 调用多次")]),e._v(" "),s("ul",[s("li",[e._v("当 Promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调")]),e._v(" "),s("li",[e._v("当 Promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调")])]),e._v(" "),s("h3",{attrs:{id:"返回"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#返回"}},[e._v("#")]),e._v(" 返回")]),e._v(" "),s("p",[s("code",[e._v("then")]),e._v(" 方法必须返回一个 Promise 对象"),s("a",{attrs:{href:"#%E6%B3%A83"}},[e._v("注 3")])]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[e._v("promise2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" promise1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("onFulfilled"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" onRejected"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("ul",[s("li",[e._v("如果 onFulfilled 或者 onRejected 返回一个值 "),s("code",[e._v("x")]),e._v(" ，则运行下面的 Promise 解决过程："),s("code",[e._v("[[Resolve]](Promise2, x)")])]),e._v(" "),s("li",[e._v("如果 onFulfilled 或者 onRejected 抛出一个异常 "),s("code",[e._v("e")]),e._v(" ，则 promise2 必须拒绝执行，并返回拒因 "),s("code",[e._v("e")])]),e._v(" "),s("li",[e._v("如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值")]),e._v(" "),s("li",[e._v("如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的拒因")])]),e._v(" "),s("p",[s("strong",[e._v("译者注")]),e._v('：理解上面的"返回"部分非常重要，即：'),s("strong",[e._v("不论 "),s("code",[e._v("promise1")]),e._v(" 被 reject 还是被 resolve 时 "),s("code",[e._v("promise2")]),e._v(" 都会被 resolve，只有出现异常时才会被 rejected。")])]),e._v(" "),s("h2",{attrs:{id:"解决过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决过程"}},[e._v("#")]),e._v(" 解决过程")]),e._v(" "),s("p",[s("strong",[e._v("Promise 解决过程")]),e._v("是一个抽象的操作，其需输入一个 Promise 和一个值，我们表示为 "),s("code",[e._v("[[Resolve]](Promise, x)")]),e._v("，如果 "),s("code",[e._v("x")]),e._v(" 有 "),s("code",[e._v("then")]),e._v(" 方法且看上去像一个 Promise ，解决程序即尝试使 Promise 接受 "),s("code",[e._v("x")]),e._v(" 的状态；否则其用 "),s("code",[e._v("x")]),e._v(" 的值来执行 Promise 。")]),e._v(" "),s("p",[e._v("这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 "),s("code",[e._v("then")]),e._v(" 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。")]),e._v(" "),s("p",[e._v("运行 "),s("code",[e._v("[[Resolve]](Promise, x)")]),e._v(" 需遵循以下步骤：")]),e._v(" "),s("h3",{attrs:{id:"x-与-promise-相等"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#x-与-promise-相等"}},[e._v("#")]),e._v(" x 与 Promise 相等")]),e._v(" "),s("p",[e._v("如果 Promise 和 x 指向同一对象，以 TypeError 为拒因拒绝执行 Promise")]),e._v(" "),s("h3",{attrs:{id:"x-为-promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#x-为-promise"}},[e._v("#")]),e._v(" x 为 Promise")]),e._v(" "),s("p",[e._v("如果 x 为 Promise ，则使 Promise 接受 x 的状态 "),s("a",{attrs:{href:"#%E6%B3%A84"}},[e._v("注 4")]),e._v("：")]),e._v(" "),s("ul",[s("li",[e._v("如果 x 处于等待态，Promise 需保持为等待态直至 x 被执行或拒绝")]),e._v(" "),s("li",[e._v("如果 x 处于执行态，用相同的值执行 Promise")]),e._v(" "),s("li",[e._v("如果 x 处于拒绝态，用相同的拒因拒绝 Promise")])]),e._v(" "),s("h3",{attrs:{id:"x-为对象或函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#x-为对象或函数"}},[e._v("#")]),e._v(" x 为对象或函数")]),e._v(" "),s("p",[e._v("如果 x 为对象或者函数：")]),e._v(" "),s("ul",[s("li",[e._v("把 "),s("code",[e._v("x.then")]),e._v(" 赋值给 "),s("code",[e._v("then")]),e._v(" "),s("a",{attrs:{href:"#%E6%B3%A85"}},[e._v("注 5")])]),e._v(" "),s("li",[e._v("如果取 "),s("code",[e._v("x.then")]),e._v(" 的值时抛出错误 "),s("code",[e._v("e")]),e._v(" ，则以 "),s("code",[e._v("e")]),e._v(" 为拒因拒绝 Promise")]),e._v(" "),s("li",[e._v("如果 "),s("code",[e._v("then")]),e._v(" 是函数，将 "),s("code",[e._v("x")]),e._v(" 作为函数的作用域 "),s("code",[e._v("this")]),e._v(" 调用之。传递两个回调函数作为参数，第一个参数叫做 "),s("code",[e._v("resolvePromise")]),e._v(" ，第二个参数叫做 "),s("code",[e._v("rejectPromise")]),e._v(":\n"),s("ul",[s("li",[e._v("如果 "),s("code",[e._v("resolvePromise")]),e._v(" 以值 "),s("code",[e._v("y")]),e._v(" 为参数被调用，则运行 [[Resolve]](Promise, y)")]),e._v(" "),s("li",[e._v("如果 "),s("code",[e._v("rejectPromise")]),e._v(" 以拒因 r 为参数被调用，则以拒因 r 拒绝 Promise")]),e._v(" "),s("li",[e._v("如果 "),s("code",[e._v("resolvePromise")]),e._v(" 和 "),s("code",[e._v("rejectPromise")]),e._v(" 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用")]),e._v(" "),s("li",[e._v("如果调用 "),s("code",[e._v("then")]),e._v(" 方法抛出了异常 "),s("code",[e._v("e")]),e._v("：\n"),s("ul",[s("li",[e._v("如果 "),s("code",[e._v("resolvePromise")]),e._v(" 或 "),s("code",[e._v("rejectPromise")]),e._v(" 已经被调用，则忽略之")]),e._v(" "),s("li",[e._v("否则以 "),s("code",[e._v("e")]),e._v(" 为拒因拒绝 Promise")])])]),e._v(" "),s("li",[e._v("如果 then 不是函数，以 x 为参数执行 Promise")])])]),e._v(" "),s("li",[e._v("如果 x 不为对象或者函数，以 x 为参数执行 Promise")])]),e._v(" "),s("p",[e._v("如果一个 Promise 被一个循环的 thenable 链中的对象解决，而 "),s("code",[e._v("[[Resolve]](Promise, thenable)")]),e._v(" 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为拒因来拒绝 Promise "),s("a",{attrs:{href:"#%E6%B3%A86"}},[e._v("注 6")]),e._v("。")]),e._v(" "),s("h2",{attrs:{id:"注释"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[e._v("#")]),e._v(" 注释")]),e._v(" "),s("h3",{attrs:{id:"注-1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注-1"}},[e._v("#")]),e._v(" 注 1")]),e._v(" "),s("p",[e._v("这里的"),s("strong",[e._v("平台代码")]),e._v("指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于 promise 的实施代码本身就是平台代码（"),s("strong",[e._v("译者注")]),e._v("：即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列。")]),e._v(" "),s("p",[s("strong",[e._v("译者注")]),e._v("：这里提及了 macrotask 和 microtask 两个概念，这表示异步任务的两种分类。在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。")]),e._v(" "),s("p",[e._v("两个类别的具体分类如下：")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("macro-task")]),e._v(": script（整体代码）、"),s("code",[e._v("setTimeout")]),e._v("、"),s("code",[e._v("setInterval")]),e._v("、setImmediate、I/O、UI rendering")]),e._v(" "),s("li",[s("strong",[e._v("micro-task")]),e._v(": process.nextTick、Promises（这里指浏览器实现的原生 Promise）、Object.observe、MutationObserver")])]),e._v(" "),s("h3",{attrs:{id:"注-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注-2"}},[e._v("#")]),e._v(" 注 2")]),e._v(" "),s("p",[e._v("在严格模式（strict）中，函数 "),s("code",[e._v("this")]),e._v(" 的值为 "),s("code",[e._v("undefined")]),e._v("；在非严格模式中其为全局对象。")]),e._v(" "),s("h3",{attrs:{id:"注-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注-3"}},[e._v("#")]),e._v(" 注 3")]),e._v(" "),s("p",[e._v("代码实现在满足所有要求的情况下可以允许 "),s("code",[e._v("promise2 === promise1")]),e._v(" 。每个实现都要文档说明其是否允许以及在何种条件下允许 "),s("code",[e._v("promise2 === promise1")]),e._v("。")]),e._v(" "),s("h3",{attrs:{id:"注-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注-4"}},[e._v("#")]),e._v(" 注 4")]),e._v(" "),s("p",[e._v("总体来说，如果 "),s("code",[e._v("x")]),e._v(" 符合当前实现，我们才认为它是真正的 Promise 。这一规则允许那些特例实现接受符合已知要求的 Promises 状态。")]),e._v(" "),s("h3",{attrs:{id:"注-5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注-5"}},[e._v("#")]),e._v(" 注 5")]),e._v(" "),s("p",[e._v("这步我们先是存储了一个指向 "),s("code",[e._v("x.then")]),e._v(" 的引用，然后测试并调用该引用，以避免多次访问 "),s("code",[e._v("x.then")]),e._v(" 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。")]),e._v(" "),s("h3",{attrs:{id:"注-6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注-6"}},[e._v("#")]),e._v(" 注 6")]),e._v(" "),s("p",[e._v("实现不应该对 thenable 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 TypeError 异常；如果一条无限长的链上 thenable 均不相同，那么递归下去永远是正确的行为。")]),e._v(" "),s("hr"),e._v(" "),s("p",[s("strong",[e._v("参考资料：")])]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://Promisesaplus.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise/A+ 规范原文"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"http://www.ituring.com.cn/article/66566",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise/A+ 规范译文"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=_.exports}}]);